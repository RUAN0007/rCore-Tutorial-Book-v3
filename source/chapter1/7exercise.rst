.. 练习

Exercises
=====================================================

.. toctree::
   :hidden:
   :maxdepth: 4


.. 课后练习

Homework
-------------------------------

.. 编程题

Programming Tasks
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1. `*` Implement a linux application program A, which displays the file names in the current directory. (code in C or Rust)
2. `***` Implement a linux application program B, which can print out the call stacktrace. (code in C or Rust)
3. `**` Implement an application C based on rcore/ucore tutorial, and use the sleep system call to sleep for 5 seconds (in rcore/ucore tutorial v3: Branch ch1)

Note: Try to use GDB (or other debugging tools) and output strings to debug the above programs, etc. Or, you can set breakpoints, execute single steps while displaying variable values, in order to understand the correspondence between assembly codes and source programs.


.. 1. `*` 实现一个linux应用程序A，显示当前目录下的文件名。（用C或Rust编程）
.. 2. `***` 实现一个linux应用程序B，能打印出调用栈链信息。（用C或Rust编程）
.. 3. `**` 实现一个基于rcore/ucore tutorial的应用程序C，用sleep系统调用睡眠5秒（in rcore/ucore tutorial v3: Branch ch1）

.. 注： 尝试用GDB等调试工具和输出字符串的等方式来调试上述程序，能设置断点，单步执行和显示变量，理解汇编代码和源程序之间的对应关系。


.. 问答题

Essay Questions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. 1. `*` 应用程序在执行过程中，会占用哪些计算机资源？
.. 2. `*` 请用相关工具软件分析并给出应用程序A的代码段/数据段/堆/栈的地址空间范围。
.. 3. `*` 请用分析并给出应用程序C的代码段/数据段/堆/栈的地址空间范围。
.. 4. `*` 请结合编译器的知识和编写的应用程序B，说明应用程序B是如何建立调用栈链信息的。
.. 5. `*` 请简要说明应用程序与操作系统的异同之处。
.. 6. `**` 请基于QEMU模拟RISC—V的执行过程和QEMU源代码，说明RISC-V硬件加电后的几条指令在哪里？完成了哪些功能？
.. 7. `*` RISC-V中的SBI的含义和功能是啥？
.. 8. `**` 为了让应用程序能在计算机上执行，操作系统与编译器之间需要达成哪些协议？
.. 9. `**` 请简要说明从QEMU模拟的RISC-V计算机加电开始运行到执行应用程序的第一条指令这个阶段的执行过程。
.. 10. `**` 为何应用程序员编写应用时不需要建立栈空间和指定地址空间？
.. 11. `***` 现代的很多编译器生成的代码，默认情况下不再严格保存/恢复栈帧指针。在这个情况下，我们只要编译器提供足够的信息，也可以完成对调用栈的恢复。

..     我们可以手动阅读汇编代码和栈上的数据，体验一下这个过程。例如，对如下两个互相递归调用的函数：

1. `*` What computer resources will an application use during its execution?
2. `*` Please analyze and give the address space range of the code segment/data segment/heap/stack of application A with relevant software tools. 
3. `*` Please analyze and give the address space range of the code segment/data segment/heap/stack of the application program C.
4. `*` Please combine the knowledge of the compiler and the application program B to explain how the application program B establishes the call stacktrace.
5. `*` Please briefly describe the similarities and differences between the application and the operating system.
6. `**` By referring to how QEMU emulates RSIV-v and QEMU source codes, explain where are the instructions after the RISC-V hardware is powered on? What functions have been completed?
7. `*` What is the meaning and function of SBI in RISC-V?
8. `**` What agreements need to be made between the operating system and the compiler in order for the application to execute on the computer?
9. `**` Please briefly explain the execution process from the power-on of the RISC-V computer simulated by QEMU to the execution of the first instruction of the application program.
10. `**` Why do application programmers need not to create stack space and specify address space when writing applications?
11. `***` The code generated by many modern compilers no longer strictly saves/restores the stack frame pointer by default. In this case, as long as the compiler provides enough information, we can also restore the call stack.

    We can manually read the assembly code and the data on the stack to experience this process. For example, for the following two functions that call each other recursively:

    .. code-block::

      void flip(unsigned n) {
          if ((n & 1) == 0) {
              flip(n >> 1);
          } else if ((n & 1) == 1) {
              flap(n >> 1);
          }
      }

      void flap(unsigned n) {
          if ((n & 1) == 0) {
              flip(n >> 1);
          } else if ((n & 1) == 1) {
              flap(n >> 1);
          }
      }

    Under certain compilation circumstances, the code generated by the compiler does not include the code to save and restore the stack frame pointer ``fp``. The following is the address of these two functions and the disassembly of the corresponding address instructions during this run output by GDB. For the convenience of reading, important control flow and stack operations are excerpted (the omitted part does not include stack operations):

    .. 在某种编译环境下，编译器产生的代码不包括保存和恢复栈帧指针 ``fp`` 的代码。以下是 GDB 输出的本次运行的时候，这两个函数所在的地址和对应地址指令的反汇编，为了方便阅读节选了重要的控制流和栈操作（省略部分不含栈操作）：

    .. code-block::

       (gdb) disassemble flap
       Dump of assembler code for function flap:
          0x0000000000010730 <+0>:     addi    sp,sp,-16    // the only entry
          0x0000000000010732 <+2>:     sd      ra,8(sp)
          ...
          0x0000000000010742 <+18>:    ld      ra,8(sp)
          0x0000000000010744 <+20>:    addi    sp,sp,16
          0x0000000000010746 <+22>:    ret                  // the only entry
          ...
          0x0000000000010750 <+32>:    j       0x10742 <flap+18>

       (gdb) disassemble flip
       Dump of assembler code for function flip:
          0x0000000000010752 <+0>:     addi    sp,sp,-16    // the only entry
          0x0000000000010754 <+2>:     sd      ra,8(sp)
          ...
          0x0000000000010764 <+18>:    ld      ra,8(sp)
          0x0000000000010766 <+20>:    addi    sp,sp,16
          0x0000000000010768 <+22>:    ret                  // the only entry
          ...
          0x0000000000010772 <+32>:    j       0x10764 <flip+18>
       End of assembler dump.

    Start this program, and interrupt it in a certain state while it is running. At this time, the values ​​of ``pc``, ``sp``, ``ra`` registers are as follows. In addition, part of the contents of the top of the stack is given below. (For the convenience of reading, some uninitialized garbage data on the stack are replaced by ``???``.)

    .. 启动这个程序，在运行的时候的某个状态将其打断。此时的 ``pc``, ``sp``, ``ra`` 寄存器的值如下所示。此外，下面还给出了栈顶的部分内容。（为阅读方便，栈上的一些未初始化的垃圾数据用 ``???`` 代替。）

    .. code-block::

       (gdb) p $pc
       $1 = (void (*)()) 0x10752 <flip>

       (gdb) p $sp
       $2 = (void *) 0x40007f1310

       (gdb) p $ra
       $3 = (void (*)()) 0x10742 <flap+18>

       (gdb) x/6a $sp
       0x40007f1310:   ???     0x10750 <flap+32>
       0x40007f1320:   ???     0x10772 <flip+32>
       0x40007f1330:   ???     0x10764 <flip+18>

    Given this information, how can the debugger recover the topmost call stacktrace? Assuming the debugger can understand the assembly code [#dwarf]_ generated by the compiler.

    .. 根据给出这些信息，调试器可以如何复原出最顶层的几个调用栈信息？假设调试器可以理解编译器生成的汇编代码 [#dwarf]_ 。



.. 实验练习

Experimental Exercises
-------------------------------

The lab exercises consist of two parts: practical assignments and question-and-answer assignments.

.. 实验练习包括实践作业和问答作业两部分。

.. 实践作业

Practical Assignments
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. 彩色化 LOG

Colorful Log
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The work of lab1 made us jump from the hardware world to the software world. Wouldn't it be nice to see that our little os can output ``hello world`` on bare metal hardware? But for the subsequent development, a better debugging environment is also essential. The exercises in the first chapter require everyone to achieve a more cool color log.

Not much to say about the detailed principles, interested students can refer to`ANSI escape sequence<https://zh.wikipedia.org/wiki/ANSI%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%97>`_ . Now execute the following command to try:

.. lab1 的工作使得我们从硬件世界跳入了软件世界，当看到自己的小 os 可以在裸机硬件上输出 ``hello world`` 是不是很高兴呢？但是为了后续的一步开发，更好的调试环境也是必不可少的，第一章的练习要求大家实现更加炫酷的彩色log。

.. 详细的原理不多说，感兴趣的同学可以参考 `ANSI转义序列 <https://zh.wikipedia.org/wiki/ANSI%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%97>`_ ，现在执行如下这条命令试试

.. code-block:: console

   $ echo -e "\x1b[31mhello world\x1b[0m"

If you understand how we use the serial port to achieve output, then it is very easy to achieve color output. Just replace ``hello world`` in the previous command with the string to output, and replace ``31 (representing red)`` with the desired color. 

.. 如果你明白了我们是如何利用串口实现输出，那么要实现彩色输出就十分容易了，只需要用需要输出的字符串替换上一条命令中的 ``hello world``，用期望颜色替换 ``31(代表红色)`` 即可。

.. warning::

  The following content is only a recommendation, not a practice requirement. Students who have time and interest can try it.

  ..  以下内容仅为推荐实现，不是练习要求，有时间和兴趣的同学可以尝试。

.. 我们推荐实现如下几个等级的输出，输出优先级依次降低：

We recommend implementing the following levels of output, with output priorities decreasing in order:

  ..  * - 名称
  ..    - 颜色
  ..    - 用途
  ..  * - ERROR
  ..    - 红色(31)
  ..    - 表示发生严重错误，很可能或者已经导致程序崩溃
  ..  * - WARN
  ..    - 黄色(93)
  ..    - 表示发生不常见情况，但是并不一定导致系统错误
  ..  * - INFO
  ..    - 蓝色(34)
  ..    - 比较中庸的选项，输出比较重要的信息，比较常用
  ..  * - DEBUG
  ..    - 绿色(32)
  ..    - 输出信息较多，在 debug 时使用
  ..  * - TRACE
  ..    - 灰色(90)
  ..    - 最详细的输出，跟踪了每一步关键路径的执行

.. list-table:: log level suggestions
   :header-rows: 1
   :align: center

   * - name
     - color
     - purpose
   * - ERROR
     - Red (31)
     - Indicates that a serious error has occurred, which may or has caused the program to crash
   * - WARN
     - Yellow (93)
     - Indicates that an uncommon condition has occurred, but does not necessarily result in a system error
   * - INFO
     - blue(34)
     - A moderate option, used to output more important information, more commonly used
   * - DEBUG
     - Green(32)
     - More output information, used when debugging
   * - TRACE
     - Gray (90)
     - The most detailed output, tracking the execution of each step of the critical path


We can output information at a higher output level than the configured output level, such as setting ``LOG = INFO``.Then it will output ``ERROR``, ``WARN``, ``INFO`` level information. A simple demo is as follows, the output level is INFO:

.. 我们可以输出比设定输出等级以及更高输出等级的信息，如设置 ``LOG = INFO``，则输出 ``ERROR``、``WARN``、``INFO`` 等级的信息。简单 demo 如下，输出等级为 INFO:

.. image:: color-demo.png

In order to facilitate the use of color output, we require students to implement color output macros or functions to replace print to complete the function of outputting kernel information. They have a format very similar to prinf and require to support parsing variable parameters, such as:

.. 为了方便使用彩色输出，我们要求同学们实现彩色输出的宏或者函数，用以代替 print 完成输出内核信息的功能，它们有着和 prinf 十分相似的使用格式，要求支持可变参数解析，形如：

.. code-block:: rust

    // This code outputs the os memory space layout, which is very important for writing os

    info!(".text [{:#x}, {:#x})", s_text as usize, e_text as usize);
    debug!(".rodata [{:#x}, {:#x})", s_rodata as usize, e_rodata as usize);
    error!(".data [{:#x}, {:#x})", s_data as usize, e_data as usize);

.. code-block:: c

    info("load range : [%d, %d] start = %d\n", s, e, start);

In the future, we can also add thread, CPU and other information to the log information (just a recommendation, not a requirement). This information will greatly facilitate your code debugging.

.. 在以后，我们还可以在 log 信息中增加线程、CPU等信息（只是一个推荐，不做要求），这些信息将极大的方便你的代码调试。


.. 实验要求

Experimental requirements
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- Implement branch: ch1
- Fulfill the requirements in the lab guide and achieve ``hello world`` output on the bare metal.
- Implement color output macros (only color output is required, log level control is not required, and multiple colors are not required)
- Implicit requirements

  All output from the kernel can be turned off. Starting from lab2 it is required to turn off all output of the kernel (if log level control is implemented, then this is naturally implemented).

- Output os memory space layout with colored output macro

  Output the positions of ``.text``, ``.data``, ``.rodata``, ``.bss``, and the output level is ``INFO``.

challenge: support multi-core, achieve the boot of multiple cores.

.. - 实现分支：ch1
.. - 完成实验指导书中的内容并在裸机上实现 ``hello world`` 输出。
.. - 实现彩色输出宏(只要求可以彩色输出，不要求 log 等级控制，不要求多种颜色)
.. - 隐形要求

..   可以关闭内核所有输出。从 lab2 开始要求关闭内核所有输出（如果实现了 log 等级控制，那么这一点自然就实现了）。

.. - 利用彩色输出宏输出 os 内存空间布局

..   输出 ``.text``、``.data``、``.rodata``、``.bss`` 各段位置，输出等级为 ``INFO``。

.. challenge: 支持多核，实现多个核的 boot。

.. 实验检查

Experimental check
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- Directory Requirement in Experiment(Rust)

.. code-block::

   ├── os(kernel implementation)
   │   ├── Cargo.toml(configurations)
   │   ├── Makefile (require to correctly run `make run LOG=xxx`，but no need to support LOG field. Set INFO as default log level)
   │   └── src(all kernal source codes under os/src)
   │       ├── main.rs(kernal main function)
   │       └── ...
   ├── reports
   │   ├── lab1.md/pdf
   │   └── ...
   ├── README.md（other explanantions if necessary）
   ├── ...

The report is named labx.md/pdf and placed under the reports directory. Each experiment adds a new report. For the convenience of modification, the inspection report is based on all the reports of the latest branch.

.. 报告命名 labx.md/pdf，统一放在 reports 目录下。每个实验新增一个报告，为了方便修改，检查报告是以最新分支的所有报告为准。

.. - 检查

- Examination

.. code-block:: console

   $ cd os
   $ git checkout ch1
   $ make run LOG=INFO

Can execute correctly (the LOG parameter may not be supported, as long as the color output is fine), and the correct memory layout output can be seen. The value may vary according to different implementations, but its address should be located in the memory behind ``BASE_ADDRESS `` indicated by ``linker.ld``. The computer is shut down after showing the output.

.. 可以正确执行(可以不支持LOG参数，只有要彩色输出就好)，可以看到正确的内存布局输出，根据实现不同数值可能有差异，但应该位于 ``linker.ld`` 中指示 ``BASE_ADDRESS`` 后一段内存，输出之后关机。

tips
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- For Rust, you can use the crate `log <https://docs.rs/log/0.4.14/log/>`_, and it is recommended to refer to `rCore <https://github.com/rcore-os/rCore/blob /master/kernel/src/logging.rs>`_
- For C, different functions can be implemented (note that multi-layer variable parameter parsing is not recommended, and sometimes instability may occur), and you can also refer to `linux printk <https://github.com/torvalds/linux/blob/master /include/linux/printk.h#L312-L385>`_  to use macros for code reuse.
- Both languages ​​can use the ``extern`` keyword to obtain symbols defined in other files.

.. - 对于 Rust, 可以使用 crate `log <https://docs.rs/log/0.4.14/log/>`_ ，推荐参考 `rCore <https://github.com/rcore-os/rCore/blob/master/kernel/src/logging.rs>`_
.. - 对于 C，可以实现不同的函数（注意不推荐多层可变参数解析，有时会出现不稳定情况），也可以参考 `linux printk <https://github.com/torvalds/linux/blob/master/include/linux/printk.h#L312-L385>`_ 使用宏实现代码重用。
.. - 两种语言都可以使用 ``extern`` 关键字获得在其他文件中定义的符号。

.. 问答作业

Question-and-Answer Assignments
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

1. Please learn how to use the gdb debugging tool (this is very important for subsequent debugging), and simply trace the simple process from powering on the machine to jumping to 0x80200000 through gdb. Only important jumps need to be described, and only the situation on qemu needs to be described.

.. 1. 请学习 gdb 调试工具的使用(这对后续调试很重要)，并通过 gdb 简单跟踪从机器加电到跳转到 0x80200000 的简单过程。只需要描述重要的跳转即可，只需要描述在 qemu 上的情况。

2. tips:

  - In fact, after entering rustsbi, there is no need to use gdb to debug. You can read the code directly. `rustsbi start code <https://github.com/rustsbi/rustsbi-qemu/blob/main/rustsbi-qemu/src/main.rs#L146>`_.
  - You can use the ``make debug`` directive in the sample code Makefile.
  - Some possible gdb commands:
      - ``x/10i 0x80000000`` : Display 10 assembly instructions at 0x80000000.
      - ``x/10i $pc`` : Display the 10 assembly instructions to be executed.
      - ``x/10xw 0x80000000`` : Display 10 pieces of data at 0x80000000, the format is hexadecimal 32bit.
      - ``info register``: Display all current register information.
      - ``info r t0``: Display the value of the t0 register.
      - ``break funcname``: Set a breakpoint at the first instruction of the target function.
      - ``break *0x80200000``: Set a breakpoint at 0x80200000.
      - ``continue``: Execute until a breakpoint is hit.
      - ``si``: Single step through an assembly instruction.

  .. - 事实上进入 rustsbi 之后就不需要使用 gdb 调试了。可以直接阅读代码。`rustsbi起始代码 <https://github.com/rustsbi/rustsbi-qemu/blob/main/rustsbi-qemu/src/main.rs#L146>`_ 。
  .. - 可以使用示例代码 Makefile 中的 ``make debug`` 指令。
  .. - 一些可能用到的 gdb 指令：
  ..     - ``x/10i 0x80000000`` : 显示 0x80000000 处的10条汇编指令。
  ..     - ``x/10i $pc`` : 显示即将执行的10条汇编指令。
  ..     - ``x/10xw 0x80000000`` : 显示 0x80000000 处的10条数据，格式为16进制32bit。
  ..     - ``info register``: 显示当前所有寄存器信息。
  ..     - ``info r t0``: 显示 t0 寄存器的值。
  ..     - ``break funcname``: 在目标函数第一条指令处设置断点。
  ..     - ``break *0x80200000``: 在 0x80200000 处设置断点。
  ..     - ``continue``: 执行直到碰到断点。
  ..     - ``si``: 单步执行一条汇编指令。

.. 实验练习的提交报告要求

Reporting Requirements for Lab Exercises
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

- Briefly summarize what you programmed for this lab. (Control within 5 lines, do not paste code)
- Since the color output is not suitable for automatic testing, please attach a screenshot of the correct operation.
- Complete questions.
- (optional) Your opinion on the design and difficulty/workload of this experiment, and what needs to be improved. Welcome to speak freely.

.. [#dwarf] For information on how the compiler provides generated code to the debugger, see the `DWARF specification <https://dwarfstd.org>`_

.. - 简单总结本次实验你编程的内容。（控制在5行以内，不要贴代码）
.. - 由于彩色输出不好自动测试，请附正确运行后的截图。
.. - 完成问答问题。
.. - (optional) 你对本次实验设计及难度/工作量的看法，以及有哪些需要改进的地方，欢迎畅所欲言。

.. .. [#dwarf] 对编译器如何向调试器提供生成的代码的信息，有兴趣可以参阅 `DWARF 规范 <https://dwarfstd.org>`_
